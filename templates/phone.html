<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI‰∫àÁ¥Ñ (WebRTC„É¢„Éº„ÉâÂº∑Âà∂)</title>
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; text-align: center; padding: 20px; background: #f0f2f5; height: 100vh; display: flex; flex-direction: column; align-items: center; }
        #status { font-size: 1.2rem; margin-bottom: 20px; color: #666; height: 1.5em; }
        .phone-btn {
            width: 200px; height: 200px; border-radius: 50%; border: none;
            font-size: 1.5rem; color: white; background: #34c759;
            box-shadow: 0 10px 25px rgba(52, 199, 89, 0.4); cursor: pointer;
            display: flex; align-items: center; justify-content: center; flex-direction: column;
            transition: all 0.3s ease;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
        }
        .phone-btn.active { background: #ff3b30; box-shadow: 0 10px 25px rgba(255, 59, 48, 0.4); }
        .phone-btn i { font-size: 3rem; margin-bottom: 10px; font-style: normal; }
        #log { 
            width: 100%; max-width: 600px; margin-top: 30px; 
            background: white; border-radius: 15px; padding: 15px;
            height: 300px; overflow-y: auto; text-align: left;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            -webkit-overflow-scrolling: touch;
        }
        .msg { margin-bottom: 8px; padding: 8px 12px; border-radius: 12px; max-width: 85%; line-height: 1.4; }
        .msg.user { background: #e9ecef; margin-left: auto; color: #333; }
        .msg.ai { background: #007bff; color: white; margin-right: auto; }
        .msg.interim { color: #888; border: 1px dashed #ccc; background: transparent; }

        /* „ÉÄ„Éü„Éº„ÅÆÈü≥Â£∞Ë¶ÅÁ¥†ÔºàWebRTCÁî®„ÉªÈùûË°®Á§∫Ôºâ */
        audio#remote-audio { display: none; }
    </style>
</head>
<body>
    <h2>üìû AI‰∫àÁ¥Ñ (WebRTC„É¢„Éº„Éâ)</h2>
    <div id="status">ÈñãÂßã„Éú„Çø„É≥„Çí„Çø„ÉÉ„Éó</div>

    <button id="callBtn" class="phone-btn" onclick="toggleCall()">
        <span id="btnIcon">üìû</span>
        <span id="btnText">ÈÄöË©±ÈñãÂßã</span>
    </button>

    <audio id="remote-audio" autoplay playsinline></audio>

    <div id="log"></div>

    <script>
        // --- Ë®≠ÂÆö ---
        // WebRTC„É¢„Éº„Éâ„Å´„Å™„Çå„Å∞„ÄÅ„Éè„Éº„Éâ„Ç¶„Çß„Ç¢AEC„ÅåÂäπ„Åè„ÅÆ„ÅßÈñæÂÄ§„ÅØ‰Ωé„Åè„Å¶OK
        const SILENCE_THRESHOLD = 5; 

        // --- Â§âÊï∞ ---
        let ws;
        let isCallActive = false;
        let audioContext;
        let processor;
        let input;
        let globalStream;
        let currentAudioElement = null; 
        let interimDiv = null; 

        // ‚òÖWebRTC„ÉÄ„Éü„ÉºÊé•Á∂öÁî®
        let peerConnection;
        let loopbackStream;

        function toggleCall() {
            if (!isCallActive) startCall();
            else endCall();
        }

        async function startCall() {
            try {
                // 1. AudioContext‰ΩúÊàê
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                await audioContext.resume();

                // 2. ‚òÖWebRTC„ÉÄ„Éü„ÉºÊé•Á∂ö„ÅÆÁ¢∫Á´ãÔºà„Åì„Åì„ÅåÊ†∏ÂøÉÔºâ‚òÖ
                // „Åì„Çå„ÇíË°å„ÅÜ„Å®„ÄÅOS„Åå„ÄåÈÄöË©±‰∏≠„Äç„Å®Ë™çË≠ò„Åó„ÄÅÂº∑Âäõ„Å™„Ç®„Ç≥„Éº„Ç≠„É£„É≥„Çª„É´„ÇíÁô∫Âãï„Åï„Åõ„Çã
                await setupDummyWebRTC();

                // 3. WebSocketÊé•Á∂ö
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                ws = new WebSocket(`${protocol}//${window.location.host}/ws`);

                ws.onopen = () => {
                    addLog("System", "Êé•Á∂öÊàêÂäü");
                    document.getElementById('status').innerText = "ÈÄöË©±‰∏≠ üü¢";
                    startRecording();
                };

                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);

                    if (data.type === "transcript") {
                        handleTranscript(data.text, data.is_final);
                    }
                    else if (data.type === "audio") {
                        addLog("AI", data.text);
                        forceStopAudio(); 
                        playAudio(data.audio);
                    }
                };

                isCallActive = true;
                updateUI(true);

            } catch (e) {
                console.error(e);
                alert("ÂàùÊúüÂåñ„Ç®„É©„Éº: " + e);
            }
        }

        // ‚òÖ„ÉÄ„Éü„Éº„ÅÆWebRTCÊé•Á∂ö„Çí‰Ωú„ÇãÈñ¢Êï∞‚òÖ
        async function setupDummyWebRTC() {
            console.log("Setting up dummy WebRTC...");
            const pc1 = new RTCPeerConnection();
            const pc2 = new RTCPeerConnection();
            peerConnection = pc1; // ‰øùÊåÅÁî®

            // ‰∫í„ÅÑ„Å´ÂÄôË£ú„Çí‰∫§Êèõ
            pc1.onicecandidate = e => e.candidate && pc2.addIceCandidate(e.candidate);
            pc2.onicecandidate = e => e.candidate && pc1.addIceCandidate(e.candidate);

            // „ÉÄ„Éü„Éº„ÅÆ„Ç™„Éº„Éá„Ç£„Ç™„Éà„É©„ÉÉ„ÇØ„Çí‰ΩúÊàê„Åó„Å¶ËøΩÂä†
            // (ÁÑ°Èü≥„ÅÆ„Éà„É©„ÉÉ„ÇØ„Å†„Åå„ÄÅ„ÄåÈü≥Â£∞ÈÄö‰ø°„Åå„ÅÇ„Çã„Äç„Å®„Éñ„É©„Ç¶„Ç∂„Å´ÊÄù„Çè„Åõ„Çã)
            const ctx = new AudioContext();
            const dest = ctx.createMediaStreamDestination();
            const osc = ctx.createOscillator(); // ÁÑ°Èü≥„Çí‰Ωú„Çã„Åü„ÇÅ
            osc.frequency.value = 0; // Âë®Ê≥¢Êï∞0 = ËÅû„Åì„Åà„Å™„ÅÑ
            osc.connect(dest);
            osc.start();
            const track = dest.stream.getAudioTracks()[0];

            pc1.addTrack(track, dest.stream);

            // Êé•Á∂ö„Ç™„Éï„Ç°„Éº„Å®„Ç¢„É≥„Çµ„Éº
            const offer = await pc1.createOffer();
            await pc1.setLocalDescription(offer);
            await pc2.setRemoteDescription(offer);
            const answer = await pc2.createAnswer();
            await pc2.setLocalDescription(answer);
            await pc1.setRemoteDescription(answer);

            // iOS SafariÂØæÁ≠ñ: output„Çíaudio„Çø„Ç∞„Å´Á¥ê‰ªò„Åë„Çã
            pc2.ontrack = e => {
                const remoteAudio = document.getElementById('remote-audio');
                remoteAudio.srcObject = e.streams[0];
            };

            console.log("Dummy WebRTC established. AEC mode should be active.");
        }

        async function startRecording() {
            // WebRTC„É¢„Éº„Éâ„Å´„Å™„Å£„Å¶„ÅÑ„ÇãÁä∂ÊÖã„Åß„Éû„Ç§„ÇØ„ÇíÂèñÂæó
            // echoCancellation: true „Åå„Éè„Éº„Éâ„Ç¶„Çß„Ç¢„É¨„Éô„É´„ÅßÂäπ„Åè„Çà„ÅÜ„Å´„Å™„Çã
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: true,
                    noiseSuppression: true,
                    autoGainControl: true // ÈÄöË©±„É¢„Éº„Éâ„Å™„ÅÆ„ÅßAGC„ÇÇON„ÅßOK
                }
            });
            globalStream = stream;

            input = audioContext.createMediaStreamSource(stream);
            processor = audioContext.createScriptProcessor(1024, 1, 1);

            // Á∞°ÊòìVAD (ÈñæÂÄ§5%)
            const analyser = audioContext.createAnalyser();
            analyser.fftSize = 256;
            input.connect(analyser);
            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            input.connect(processor);
            processor.connect(audioContext.destination);

            processor.onaudioprocess = (e) => {
                if (!isCallActive || ws.readyState !== WebSocket.OPEN) return;

                // VAD„ÉÅ„Çß„ÉÉ„ÇØ
                analyser.getByteFrequencyData(dataArray);
                let sum = 0;
                for(let i=0; i<dataArray.length; i++) sum += dataArray[i];
                const average = sum / dataArray.length;
                const vol = Math.floor((average / 255) * 100);

                if (vol < SILENCE_THRESHOLD) return;

                // ÈÄÅ‰ø°
                const inputData = e.inputBuffer.getChannelData(0);
                const downsampled = downsampleBuffer(inputData, audioContext.sampleRate, 16000);
                const pcmData = convertFloat32ToInt16(downsampled);
                ws.send(pcmData);
            };
        }

        function endCall() {
            isCallActive = false;
            updateUI(false);
            if (ws) ws.close();
            if (globalStream) globalStream.getTracks().forEach(track => track.stop());
            if (processor) processor.disconnect();
            if (input) input.disconnect();
            if (audioContext) audioContext.close();

            // WebRTCÂàáÊñ≠
            if (peerConnection) peerConnection.close();

            forceStopAudio();
            document.getElementById('status').innerText = "ÈÄöË©±ÁµÇ‰∫Ü";
        }

        function handleTranscript(text, isFinal) {
            const logDiv = document.getElementById('log');
            if (isFinal) {
                if (interimDiv) { interimDiv.remove(); interimDiv = null; }
                addLog("„ÅÇ„Å™„Åü", text);
            } else {
                if (!interimDiv) {
                    interimDiv = document.createElement('div');
                    interimDiv.className = 'msg user interim';
                    logDiv.appendChild(interimDiv);
                }
                interimDiv.innerText = text + "...";
                logDiv.scrollTop = logDiv.scrollHeight;
            }
        }

        function downsampleBuffer(buffer, sampleRate, outSampleRate) {
            if (outSampleRate === sampleRate) return buffer;
            if (outSampleRate > sampleRate) return buffer;
            const sampleRateRatio = sampleRate / outSampleRate;
            const newLength = Math.round(buffer.length / sampleRateRatio);
            const result = new Float32Array(newLength);
            let offsetResult = 0;
            let offsetBuffer = 0;
            while (offsetResult < result.length) {
                const nextOffsetBuffer = Math.round((offsetResult + 1) * sampleRateRatio);
                let accum = 0, count = 0;
                for (let i = offsetBuffer; i < nextOffsetBuffer && i < buffer.length; i++) {
                    accum += buffer[i];
                    count++;
                }
                result[offsetResult] = accum / count;
                offsetResult++;
                offsetBuffer = nextOffsetBuffer;
            }
            return result;
        }

        function convertFloat32ToInt16(buffer) {
            let l = buffer.length;
            const buf = new Int16Array(l);
            while (l--) {
                let s = Math.max(-1, Math.min(1, buffer[l]));
                buf[l] = s < 0 ? s * 0x8000 : s * 0x7FFF;
            }
            return buf.buffer;
        }

        function playAudio(base64Data) {
            const audio = new Audio("data:audio/mp3;base64," + base64Data);
            audio.crossOrigin = "anonymous";
            // AudioContextÁµåÁî±„ÅßÂÜçÁîüÔºà„Åì„Çå„ÅåÈáçË¶ÅÔºÅÔºâ
            if (audioContext && audioContext.state === 'running') {
                const source = audioContext.createMediaElementSource(audio);
                source.connect(audioContext.destination);
            }
            currentAudioElement = audio;
            audio.play().catch(e => console.error(e));
        }

        function forceStopAudio() {
            if (currentAudioElement) {
                currentAudioElement.pause();
                currentAudioElement.currentTime = 0;
                currentAudioElement = null;
            }
        }

        function addLog(role, text) {
            const log = document.getElementById('log');
            const div = document.createElement('div');
            div.className = `msg ${role === 'AI' ? 'ai' : role === 'System' ? 'system' : 'user'}`;
            div.innerText = text;
            log.appendChild(div);
            log.scrollTop = log.scrollHeight;
        }

        function updateUI(active) {
            const btn = document.getElementById('callBtn');
            const text = document.getElementById('btnText');
            if (active) {
                btn.classList.add('active');
                text.innerText = "ÂàáÊñ≠";
            } else {
                btn.classList.remove('active');
                text.innerText = "ÈÄöË©±ÈñãÂßã";
            }
        }
    </script>
</body>
</html>